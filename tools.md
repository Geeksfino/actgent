# Tool Development Guide

This guide explains how to implement custom tools in the Actgent framework. Tools are modular components that provide specific functionalities like calculations, web searches, or API interactions.

## Basic Structure

Every tool must extend the base `Tool` class and implement required methods:

## Key Components

1. **Type Parameters**

   - `TInput`: The expected input type. This is a structured output generated by an LLM to be passed to the tool for processing.
   - `TOutput`: The output type (must extend `ToolOutput`). As a result of tool execution, something is usually returned so that the agent can further handle it.

2. **Constructor**

   - Define tool name and description
   - Initialize any required resources
   - Set up tool options

3. **Schema**

A schema is a defined structure which an LLM needs to conform to for outputting response. 
   - Define input validation using Zod
   - Specify required fields and their types
   - Add field descriptions for better documentation

4. **Execute Method**
   - Implement the core tool logic
   - Handle errors appropriately
   - Return results in the specified output format


```TypeScript
export class CustomTool extends Tool<TInput, TOutput> {
constructor() {
super(
"ToolName",
"Tool Description"
);
}
schema(): z.ZodSchema<TInput> {
// Define input validation schema
}
protected async execute(
input: TInput,
context: ExecutionContext,
options: RunOptions
): Promise<TOutput> {
// Implement tool logic
}
}
```

## Example: Calculator Tool

Let's examine the Calculator tool as a practical example:

### Key Features of the Calculator Example:

1. **Input Definition**: Simple interface with an expression string
2. **Input Validation**: Uses Zod schema to ensure valid input
3. **Security**: Initializes math engine with restricted functions
4. **Error Handling**: Proper error catching and meaningful messages
5. **Metadata**: Includes original expression in output metadata

## Development Guidelines

1. **Input Validation**

   - Always define comprehensive input validation
   - Include descriptive messages for validation errors
   - Set appropriate limits for numerical inputs

2. **Error Handling**

   - Use try-catch blocks for error-prone operations
   - Provide specific error messages
   - Consider retrying for transient failures

3. **Security**

   - Validate and sanitize inputs
   - Restrict dangerous operations
   - Handle sensitive data appropriately

4. **Performance**

   - Initialize expensive resources in constructor
   - Consider caching when appropriate
   - Implement timeouts for external operations

5. **Output Format**

   - Use `StringOutput` for text results
   - Use `JSONOutput` for structured data
   - Include relevant metadata

6. **Documentation**
   - Provide clear descriptions in constructor
   - Document input parameters in schema
   - Include usage examples in comments

```TypeScript
interface CalculatorInput {
expression: string;
}
export class CalculatorTool extends Tool<CalculatorInput, StringOutput> {
private readonly mathInstance;
constructor() {
super(
"Calculator",
"A calculator tool that performs basic arithmetic operations"
);
// Initialize math.js instance with security restrictions
this.mathInstance = create(all);
// Disable potentially dangerous functions...
}
schema(): z.ZodSchema<CalculatorInput> {
return z.object({
expression: z
.string()
.min(1)
.describe("The mathematical expression to evaluate")
});
}
protected async execute(
input: CalculatorInput,
context: ExecutionContext,
options: RunOptions
): Promise<StringOutput> {
try {
const result = this.mathInstance.compile(input.expression).evaluate();
return new StringOutput(
result.toString(),
{ expression: input.expression }
);
} catch (error) {
throw new Error(Calculation error: ${error.message});
}
}
}
```

## Best Practices

1. **Modularity**

   - Keep tools focused on single responsibility
   - Avoid dependencies between tools
   - Make tools configurable via constructor options

2. **Resource Management**

   - Clean up resources when tool is destroyed
   - Handle timeouts and cancellations
   - Respect AbortSignal from options

3. **Testing**

   - Write unit tests for each tool
   - Test error conditions
   - Mock external dependencies

4. **Type Safety**
   - Use TypeScript interfaces for input/output
   - Leverage generics appropriately
   - Maintain strict type checking

## Common Pitfalls to Avoid

1. Not handling network timeouts
2. Insufficient input validation
3. Ignoring error contexts
4. Missing type definitions
5. Inadequate error messages

## Tool Output Types

1. **StringOutput**: For text-based results
2. **JSONOutput**: For structured data
3. Custom outputs must extend `ToolOutput`

Remember to always consider security, error handling, and proper input validation when developing new tools.

